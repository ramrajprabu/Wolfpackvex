{"mode":"Text","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\nbrain_inertial = Inertial()\nleft_drive_smart = Motor(Ports.PORT5, 1.0, False)\nright_drive_smart = Motor(Ports.PORT11, 1.0, True)\n\ndrivetrain = SmartDrive(left_drive_smart, right_drive_smart, brain_inertial, 200)\nAutonomous = Touchled(Ports.PORT8)\nLift_motor_a = Motor(Ports.PORT10, False)\nLift_motor_b = Motor(Ports.PORT4, True)\nLift = MotorGroup(Lift_motor_a, Lift_motor_b)\nIntake_motor_a = Motor(Ports.PORT6, True)\nIntake_motor_b = Motor(Ports.PORT12, False)\nIntake = MotorGroup(Intake_motor_a, Intake_motor_b)\nAutoRedo = Touchled(Ports.PORT2)\nBottomBumper = Bumper(Ports.PORT9)\nDistanceSensor = Distance(Ports.PORT1)\n\n\n\n# Make random actually random\ndef setRandomSeedUsingAccel():\n    wait(100, MSEC)\n    xaxis = brain_inertial.acceleration(XAXIS) * 1000\n    yaxis = brain_inertial.acceleration(YAXIS) * 1000\n    zaxis = brain_inertial.acceleration(ZAXIS) * 1000\n    urandom.seed(int(xaxis + yaxis + zaxis))\n    \n# Set random seed \nsetRandomSeedUsingAccel()\n\nvexcode_initial_drivetrain_calibration_completed = False\ndef calibrate_drivetrain():\n    # Calibrate the Drivetrain Inertial\n    global vexcode_initial_drivetrain_calibration_completed\n    sleep(200, MSEC)\n    brain.screen.print(\"Calibrating\")\n    brain.screen.next_row()\n    brain.screen.print(\"Inertial\")\n    brain_inertial.calibrate()\n    while brain_inertial.is_calibrating():\n        sleep(25, MSEC)\n    vexcode_initial_drivetrain_calibration_completed = True\n    brain.screen.clear_screen()\n    brain.screen.set_cursor(1, 1)\n\n#endregion VEXcode Generated Robot Configuration\n\n# ------------------------------------------\n# \n# \tProject:      Autonomous\n# \tAuthor:       Team WolfPack\n# \tCreated:      January 20th, 2024\n# \tDescription:  VEXcode IQ Python Project\n# \n# ------------------------------------------\n\n# Library imports\nfrom vex import *\nimport math\n\n# Total length: 470 mm\n# Length of back after brain: 20 mm\n# Length of back with brain: 120 mm\n# Length of front before brain: 350 mm\n\n# Use lengths: -350 going forward, -20 going backwards\n\n# Variables\nAutoSection = 0\nIfDriving = False\nsection = 1\ncurrentX = 1650\ncurrentY = 120\n# 125\ndebug = True\nwalldistance = 5\nGoal1 = [150, 1650]\nGoal2 = [150, 150]\nGoal3 = [2250, 150]\nFlower1 = [150, 750]\nFlower2 = [750, 1650]\nFlower3 = [1350, 1650]\nFlower4 = [1950, 750]\nGreenLine1 = [450, 450]\nGreenLine2 = [1650, 450]\nCenter = [1050, 1050]\nRed1 = [750, 1350]\nRed2 = [1350, 1350]\nRed3 = [1050, 450]\nSupplyZone1 = [1950, 1350]\nSupplyZone2 = [2250, 1050]\ndef dump():\n    drivetrain.drive_for(FORWARD, 50, MM)\n    drivetrain.drive_for(REVERSE, 50, MM)\n\n# Setup\n    # Calibration\ncalibrate_drivetrain()\nbrain_inertial.calibrate()\n    # Set TouchLED colors\nAutonomous.set_color(Color.RED)\nAutoRedo.set_color(Color.PURPLE)\n    # Set stopping and motor/drivetrain velocities\ndrivetrain.set_stopping(BRAKE)\ndrivetrain.set_drive_velocity(100, PERCENT)\ndrivetrain.set_turn_velocity(50, PERCENT)\nIntake.set_velocity(90, PERCENT)\n    # Bring lift to bottom\nwhile not BottomBumper.pressing():\n    Lift.spin(FORWARD)\nLift.stop()\nLift.set_position(0, DEGREES)\n    # 1100 from purple to green dump\n    # Bring lift to middle position and set variable\nLift.spin_for(REVERSE, 150, DEGREES)\nmidlift = Lift.position(DEGREES)\n\ndef msgprint(msg):\n    print(msg)\n\ndef printcurpos():\n    print(\"Current position: (\"+str(currentX)+\", \"+str(currentY)+\")\")\n\ndef goto(mode, fw, x, y):\n    global currentX\n    global currentY\n    global debug\n    global walldistance\n    startdrivetrain=drivetrain.heading(DEGREES)\n    currentX = currentX\n    currentY = currentY\n    errorX = x - currentX\n    errorY = y - currentY\n    if mode == 1:\n        # Diagonally\n        abserY = abs(errorY)\n        abserX = abs(errorX)\n        hypotenuse = math.sqrt(abserY**2 + abserX**2)\n        turnto = math.degrees(math.asin(abserX/hypotenuse))\n        if debug:\n            msgprint(\"errorX: \"+str(errorX))\n            msgprint(\"errorY: \"+str(errorY))\n            msgprint(\"absolute value errorX: \" + str(abserX))\n            msgprint(\"absolute value errorY: \" + str(abserY))\n            msgprint(\"hypotenuse: \" + str(hypotenuse))\n            msgprint(\"turnto: \" + str(turnto))\n        if fw == True:\n            if errorX > 0 and errorY > 0:\n                # errorX & errorY positive: turn to heading y alpha\n                drivetrain.turn_to_heading(turnto, DEGREES)\n                if debug:\n                    msgprint(\"Turned to \" + str(turnto) + \" degrees\")\n            elif errorX < 0 and errorY < 0:\n                # errorX & errorY negative: 180 + y alpha\n                drivetrain.turn_to_heading(180 + turnto, DEGREES)\n                if debug:\n                    msgprint(\"Turned to \" + str(180 + turnto) + \" degrees\")\n            elif errorX < 0 and errorY > 0:\n                # errorX positive & errorY negative: 360 - y alpha\n                drivetrain.turn_to_heading(360 - turnto, DEGREES)\n                if debug:\n                    msgprint(\"Turned to \" + str(360 - turnto) + \" degrees\")\n            else:\n                # errorX negative & errorY positive: 90 + x alpha\n                drivetrain.turn_to_heading(90 + (90 - turnto), DEGREES)\n                if debug:\n                    msgprint(\"Turned to \" + str(90 + (90 - turnto)) + \" degrees\")\n            drivetrain.drive_for(FORWARD, hypotenuse, MM)\n            if debug:\n                msgprint(\"Drove for \" + str(hypotenuse) + \" millimeters\")\n        else:\n            msgprint(str(turnto))\n            if errorX > 0 and errorY > 0:\n                turnto = turnto + 180\n                # errorX & errorY positive: turn to heading y alpha\n                drivetrain.turn_to_heading(turnto, DEGREES)\n            elif errorX < 0 and errorY < 0:\n                turnto = turnto + 180\n                # errorX & errorY negative: 180 + y alpha\n                drivetrain.turn_to_heading(180 + turnto, DEGREES)\n            elif errorX < 0 and errorY > 0:\n                turnto = turnto + 180\n                # errorX positive & errorY negative: 360 - y alpha\n                drivetrain.turn_to_heading(360 - turnto, DEGREES)\n            else:\n                # errorX negative & errorY positive: 90 + x alpha\n                turnto = turnto + 180\n                drivetrain.turn_to_heading(90 + (90 - turnto), DEGREES)\n            drivetrain.drive_for(REVERSE, hypotenuse, MM)\n    elif mode == 2:\n        # Step (x, y)\n        if x > currentX:\n            if fw:\n                drivetrain.turn_to_heading(90, DEGREES)\n                drivetrain.drive_for(FORWARD, abs(errorX), MM)\n            else:\n                drivetrain.turn_to_heading(270, DEGREES)\n                drivetrain.drive_for(REVERSE, abs(errorX), MM)\n        else:\n            if fw:\n                drivetrain.turn_to_heading(270, DEGREES)\n                drivetrain.drive_for(FORWARD, abs(errorX), MM)\n            else:\n                drivetrain.turn_to_heading(90, DEGREES)\n                drivetrain.drive_for(REVERSE, abs(errorX), MM)\n        if y > currentY:\n            if fw:\n                drivetrain.turn_to_heading(0, DEGREES)\n                drivetrain.drive_for(FORWARD, abs(errorY), MM)\n            else:\n                drivetrain.turn_to_heading(180, DEGREES)\n                drivetrain.drive_for(REVERSE, abs(errorY), MM)\n        else:\n            if fw:\n                drivetrain.turn_to_heading(180, DEGREES)\n                drivetrain.drive_for(FORWARD, abs(errorY), MM)\n            else:\n                drivetrain.turn_to_heading(0, DEGREES)\n                drivetrain.drive_for(REVERSE, abs(errorY), MM)\n    elif mode == 3:\n        # Step (y, x)\n        if y > currentY:\n            if fw:\n                drivetrain.turn_to_heading(0, DEGREES)\n                drivetrain.drive_for(FORWARD, abs(errorY), MM)\n            else:\n                drivetrain.turn_to_heading(180, DEGREES)\n                drivetrain.drive_for(REVERSE, abs(errorY), MM)\n        else:\n            if fw:\n                drivetrain.turn_to_heading(180, DEGREES)\n                drivetrain.drive_for(FORWARD, abs(errorY), MM)\n            else:\n                drivetrain.turn_to_heading(0, DEGREES)\n                drivetrain.drive_for(REVERSE, abs(errorY), MM)\n        if x > currentX:\n            if fw:\n                drivetrain.turn_to_heading(90, DEGREES)\n                drivetrain.drive_for(FORWARD, abs(errorX), MM)\n            else:\n                drivetrain.turn_to_heading(270, DEGREES)\n                drivetrain.drive_for(REVERSE, abs(errorX), MM)\n        else:\n            if fw:\n                drivetrain.turn_to_heading(270, DEGREES)\n                drivetrain.drive_for(FORWARD, abs(errorX), MM)\n            else:\n                drivetrain.turn_to_heading(90, DEGREES)\n                drivetrain.drive_for(REVERSE, abs(errorX), MM)\n    elif mode == 4:\n        # One axis\n        if debug:\n            msgprint(\"errorX: \"+str(errorX))\n            msgprint(\"errorY: \"+str(errorY))\n        if errorX == 0:\n            # Travel along Y axis\n            if y > currentY:\n                if fw:\n                    drivetrain.turn_to_heading(0, DEGREES)\n                    drivetrain.drive_for(FORWARD, abs(errorY), MM)\n                else:\n                    drivetrain.turn_to_heading(180, DEGREES)\n                    drivetrain.drive_for(REVERSE, abs(errorY), MM)\n            else:\n                if fw:\n                    drivetrain.turn_to_heading(180, DEGREES)\n                    drivetrain.drive_for(FORWARD, abs(errorY), MM)\n                else:\n                    drivetrain.turn_to_heading(0, DEGREES)\n                    drivetrain.drive_for(REVERSE, abs(errorY), MM)\n        elif errorY == 0:\n            if x > currentX:\n                if fw:\n                    drivetrain.turn_to_heading(90, DEGREES)\n                    drivetrain.drive_for(FORWARD, abs(errorX), MM)\n                else:\n                    drivetrain.turn_to_heading(270, DEGREES)\n                    drivetrain.drive_for(REVERSE, abs(errorX), MM)\n            else:\n                if fw:\n                    drivetrain.turn_to_heading(270, DEGREES)\n                    drivetrain.drive_for(FORWARD, abs(errorX), MM)\n                else:\n                    drivetrain.turn_to_heading(90, DEGREES)\n                    drivetrain.drive_for(REVERSE, abs(errorX), MM)\n        else:\n            goto(2, fw, x, y)\n            msgprint(\"2 axes changed\")\n    else:\n        msgprint(\"Error\")\n    currentX = x\n    currentY = y\n    enddrivetrain=drivetrain.heading(DEGREES)\n    change = enddrivetrain - startdrivetrain\n    msgprint(\"Drivetrain heading in degrees>\" + str(enddrivetrain))\n    printcurpos()\n    print(\"///////\")\n\ndef distancepark(x, y, axis):\n    global currentX\n    global currentY\n    sensorOffset = 18;\n    brainOffsetY = 120;\n    if axis == \"x\":\n        goto(4, False, x, y)\n    else:\n        drivetrain.drive(REVERSE)\n        while DistanceSensor.object_distance(MM) > (y + sensorOffset -brainOffsetY):\n            print(DistanceSensor.object_distance(MM))\n            brain.play_note(3,0,250)\n        print(\"reached sensor stop\")\n        drivetrain.stop()\n        \n        currentY = DistanceSensor.object_distance(MM) + (brainOffsetY - sensorOffset);\n        printcurpos()\n\n    #    goto(4, False, x, y-step)\n    # while DistanceSensor.object_distance(MM) > dist:\n        # drivetrain.drive_for(REVERSE, step, MM)\n        # print(DistanceSensor.object_distance(MM))\n    # drivetrain.stop()\n    \ndef dumpPurple():\n    global midlift\n    Lift.spin_to_position(midlift, DEGREES)\n    Lift.spin_for(FORWARD, 140, DEGREES)\n    wait(500, MSEC)\n    #dump()\n    #wait(500, MSEC)\n    Lift.spin_to_position(midlift, DEGREES)\ndef dumpGreen():\n    global midlift\n    Lift.spin_to_position(midlift, DEGREES)\n    # Original position for dumping green - rotate forward for 985 degrees\n    # Feb 1 position for dumping green - 1090 (original + 105)\n    # Feb 3 position for dumping green - \n    Lift.spin_for(REVERSE, 1800, DEGREES)\n    #wait(500, MSEC)\n    #dump()\n    Lift.spin_to_position(midlift, DEGREES, wait=False)\n    wait(100, MSEC)\n\ndef greenedit():\n    global section\n    global currentX\n    global currentY\n    if section == 1:\n        Intake.spin(FORWARD)\n        goto(4, True, 450, 900)\n        #wait(1, SECONDS)\n        goto(4, False, 450, 140)\n        goto(1, True, 600, 100)\n        Intake.stop()\n        goto(4, False, 390, 100)\n        dumpGreen()\n        # First dump\n        Intake.spin(FORWARD)\n        goto(4, True, 450, 100)\n        goto(1, True, 725, 330)\n        goto(1, False, 450, 200)\n        goto(1, True, 1100, 1100)\n        goto(1, False, 750, 750)\n        goto(1, False, 450, 1060)\n        goto(4, False, 180, 1060)\n        goto(1, False, 160, 1290)\n        dumpGreen()\n        # Second dump\n        Intake.stop()\n        section = 2\n        drivetrain.set_stopping(BRAKE)\n    elif section == 2:\n        Autonomous.set_color(Color.BLUE)\n        AutoRedo.set_color(Color.BLUE_GREEN)\n        drivetrain.set_stopping(HOLD)\n        currentX = 1650\n        currentY = 120\n        printcurpos()\n        #calibrate_drivetrain()\n        #drivetrain.set_heading(0, DEGREES)\n        Intake.spin(FORWARD)\n        goto(4, True, 1650, 900)\n        #wait(1, SECONDS)\n        goto(4, False, 1650, 140)\n        goto(1, True, 1500, 100)\n        Intake.stop()\n        goto(1, False, 1950, 90)\n        dumpGreen()\n        # Third dump\n        goto(1, True, 2200, 925)\n        drivetrain.stop()\n        Intake.stop()\n    else:\n        Autonomous.set_color(Color.BLACK)\n\ndef newgreen():\n    global section\n    global currentX\n    global currentY\n    if section == 1:\n        Intake.spin(FORWARD)\n        goto(4, True, 450, 900)\n        #wait(1, SECONDS)\n        # goto(4, False, 450, 140)\n        goto(1, True, 925, 400)\n        # goto(1, True, 600, 100)\n        Intake.stop()\n        goto(4, False, 390, 100)\n        dumpGreen()\n        # First dump\n        Intake.spin(FORWARD)\n        goto(4, True, 450, 100)\n        goto(1, True, 725, 330)\n        goto(1, False, 450, 200)\n        goto(1, True, 1100, 1100)\n        goto(1, False, 750, 750)\n        goto(1, False, 450, 1050)\n        goto(2, False, 200, 1325)\n        dumpGreen()\n        # Second dump\n        Intake.stop()\n        section = 2\n        drivetrain.set_stopping(BRAKE)\n    elif section == 2:\n        Autonomous.set_color(Color.BLUE)\n        AutoRedo.set_color(Color.BLUE_GREEN)\n        drivetrain.set_stopping(HOLD)\n        currentX = 1650\n        currentY = 120\n        printcurpos()\n        #calibrate_drivetrain()\n        #drivetrain.set_heading(0, DEGREES)\n        Intake.spin(FORWARD)\n        goto(4, True, 1650, 900)\n        #wait(1, SECONDS)\n        goto(4, False, 1650, 140)\n        goto(1, True, 1500, 100)\n        Intake.stop()\n        goto(1, False, 1950, 90)\n        dumpGreen()\n        # Third dump\n        goto(1, True, 2200, 925)\n        drivetrain.stop()\n        Intake.stop()\n    else:\n        Autonomous.set_color(Color.BLACK)\n\ndef redosection():\n    global section\n    AutoRedo.set_color(Color.BLUE_GREEN)\n    drivetrain.stop()\n    Lift.stop()\n    Intake.stop()\n    AutoRedo.set_color(Color.PURPLE)\n    brain.screen.print(str(section))\n\ndef route():\n    Intake.spin(FORWARD)\n    goto(4, True, 450, 800)\n    goto(1, False, 780, 150)\n    goto(1, False, 390, 90)\n    dumpGreen()\n    wait(200, MSEC)\n    goto(1, True, 1615, 150)\n    goto(4, True, 1615, 800)\n    goto(1, False, 1550, 150)\n    goto(1, False, 1940, 90)\n    dumpGreen()\n    wait(300, MSEC)\n    goto(4, True, 1950, 150)\n    goto(1, True, 850, 1000)\n    goto(4, False, 450, 1050)\n    goto(1, False, 600, 1650)\n    goto(1, False, 390, 1700)\n    dumpGreen()\n    wait(200, MSEC)\n    goto(1, True, 550, 1450)\n    goto(4, True, 2000, 1450)\n    Intake.stop()\n    Lift.stop()\n    drivetrain.stop()\n\ndef routetwo():\n    Intake.spin(FORWARD)\n    goto(4, True, 1650, 900)\n    distancepark(1650, 120, \"y\")\n    goto(1, False, 1750, 120)\n    goto(1, False, 1950, 120)\n    brain.play_note(3, 0, 1000)\n\n    \n    #wait(50, SECONDS)\n    #goto(1, False, 1550, 150)\n    # wait(10,SECONDS)\n    # print(\"#currentX \" + str(currentX))\n    # print(\"#currentY \" + str(currentY))\n    # print(\"distance measured:\" + str(DistanceSensor.object_distance()))\n    #goto(1, False, 1923, 77)\n    # Use bumper to park in front of goal\n    dumpGreen()\n    #checking drift\n    wait(500, MSEC)\n    goto(4, True, 1880, 77)\n    goto(1, True, 985, 1075)\n    goto(4, True, 200, 1075)\n    distancepark(150, 1230, \"y\")\n    # Use bumper to park in front of goal\n    dumpGreen()\n    wait(200, MSEC)\n    Intake.stop()\n    drivetrain.stop()\n    Lift.stop()\n\n#currentX = 1650\n#currentY = 120\ndef malar():\n    print(\"spinning intake\")\n    Intake.spin(FORWARD)\n    goto(4, True, 1650, 1000)\n    print(\"done\")\n    Intake.stop()\n    drivetrain.stop()\n    Lift.stop()\n\n# Run autonomous\ndrivetrain.set_stopping(HOLD)\ndrivetrain.set_drive_velocity(90, PERCENT)\ndrivetrain.set_turn_velocity(50, PERCENT)\nLift.set_velocity(100, PERCENT)\ncalibrate_drivetrain()\ndrivetrain.set_heading(0, DEGREES)\n# while True:\n    # print(DistanceSensor.object_distance())\n    \nAutonomous.pressed(routetwo)\nAutoRedo.pressed(redosection)\n\n","textLanguage":"python","rconfig":[{"port":[5,11,0],"name":"drivetrain","customName":false,"deviceType":"Drivetrain","deviceClass":"smartdrive","setting":{"type":"2-motor","wheelSize":"200mm","gearRatio":"1:1","direction":"fwd","gyroType":"integrated","width":"173","unit":"mm","wheelbase":"76","wheelbaseUnit":"mm","xOffset":"0","yOffset":"0","thetaOffset":"0"},"triportSourcePort":22},{"port":[8],"name":"Autonomous","customName":true,"deviceType":"TouchLED","deviceClass":"touchled","setting":{},"triportSourcePort":22},{"port":[10,4],"name":"Lift","customName":true,"deviceType":"MotorGroup","deviceClass":"motor_group","setting":{"fwd":"forward","rev":"reverse","motor_a_reversed":"false","motor_b_reversed":"true"},"triportSourcePort":22},{"port":[6,12],"name":"Intake","customName":true,"deviceType":"MotorGroup","deviceClass":"motor_group","setting":{"fwd":"forward","rev":"reverse","motor_a_reversed":"true","motor_b_reversed":"false"},"triportSourcePort":22},{"port":[2],"name":"AutoRedo","customName":true,"deviceType":"TouchLED","deviceClass":"touchled","setting":{},"triportSourcePort":22},{"port":[9],"name":"BottomBumper","customName":true,"deviceType":"Bumper","deviceClass":"bumper","setting":{},"triportSourcePort":22},{"port":[1],"name":"DistanceSensor","customName":true,"deviceType":"Distance","deviceClass":"distance","setting":{},"triportSourcePort":22}],"slot":2,"platform":"IQ","sdkVersion":"20230818.11.00.00","appVersion":"3.0.4","minVersion":"3.0.0","fileFormat":"1.2.0","icon":"","targetBrainGen":"Second","v5SoundsEnabled":false,"target":"Physical"}